--- ../src-base/minecraft/net/minecraft/world/storage/ThreadedFileIOBase.java
+++ ../src-work/minecraft/net/minecraft/world/storage/ThreadedFileIOBase.java
@@ -1,22 +1,24 @@
 package net.minecraft.world.storage;
 
-import com.google.common.collect.Lists;
-import java.util.Collections;
-import java.util.List;
+import com.google.common.collect.Queues;
+import gg.m2ke4u.skylight.config.WorkerConfig;
+import java.util.Queue;
+import java.util.concurrent.atomic.AtomicLong;
 
 public class ThreadedFileIOBase implements Runnable
 {
     private static final ThreadedFileIOBase INSTANCE = new ThreadedFileIOBase();
-    private final List<IThreadedFileIO> threadedIOQueue = Collections.<IThreadedFileIO>synchronizedList(Lists.newArrayList());
-    private volatile long writeQueuedCounter;
-    private volatile long savedIOCounter;
-    private volatile boolean isThreadWaiting;
+    private final Queue<IThreadedFileIO> threadedIOQueue = Queues.newConcurrentLinkedQueue();
+    private final AtomicLong activeCount = new AtomicLong();
+    private final Object waiter = new Object();
 
     private ThreadedFileIOBase()
     {
-        Thread thread = new Thread(this, "File IO Thread");
-        thread.setPriority(1);
-        thread.start();
+        for (int i = 0; i < WorkerConfig.IO_WORKER_THREADS; i++) {
+            Thread thread = new Thread(this, "File IO Thread # "+i);
+            thread.setPriority(1);
+            thread.start();
+        }
     }
 
     public static ThreadedFileIOBase getThreadedIOInstance()
@@ -26,7 +28,7 @@
 
     public void run()
     {
-        while (true)
+        for (;;)
         {
             this.processQueue();
         }
@@ -34,32 +36,23 @@
 
     private void processQueue()
     {
-        for (int i = 0; i < this.threadedIOQueue.size(); ++i)
-        {
-            IThreadedFileIO ithreadedfileio = this.threadedIOQueue.get(i);
-            boolean flag = ithreadedfileio.writeNextIO();
-
-            if (!flag)
+        IThreadedFileIO ithreadedfileio;
+        this.activeCount.set(this.threadedIOQueue.size());
+        while ((ithreadedfileio = this.threadedIOQueue.poll())!=null){
+            if (ithreadedfileio.writeNextIO())
             {
-                this.threadedIOQueue.remove(i--);
-                ++this.savedIOCounter;
+                this.threadedIOQueue.add(ithreadedfileio);
             }
-
-            try
-            {
-                Thread.sleep(this.isThreadWaiting ? 0L : 10L);
-            }
-            catch (InterruptedException interruptedexception1)
-            {
-                interruptedexception1.printStackTrace();
-            }
+            this.activeCount.getAndDecrement();
         }
 
         if (this.threadedIOQueue.isEmpty())
         {
             try
             {
-                Thread.sleep(25L);
+                synchronized (this.waiter){
+                    this.waiter.wait();
+                }
             }
             catch (InterruptedException interruptedexception)
             {
@@ -72,20 +65,17 @@
     {
         if (!this.threadedIOQueue.contains(fileIo))
         {
-            ++this.writeQueuedCounter;
             this.threadedIOQueue.add(fileIo);
         }
     }
 
     public void waitForFinish() throws InterruptedException
     {
-        this.isThreadWaiting = true;
-
-        while (this.writeQueuedCounter != this.savedIOCounter)
-        {
-            Thread.sleep(10L);
+        synchronized (this.waiter){
+            while (this.activeCount.get() > 0 && !this.threadedIOQueue.isEmpty())
+            {
+                this.waiter.wait();
+            }
         }
-
-        this.isThreadWaiting = false;
     }
 }
